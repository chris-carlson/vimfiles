# Variables

snippet vari "variable initialization"
${1:type} ${2:var} = ${3:value};
endsnippet

snippet varc "variable initialization with constructor"
${1:type} ${2:var} = new $1(${3:params});
endsnippet

snippet vara "variable assignment"
${1:var} = ${2:value};
endsnippet

snippet vart "this assignment"
this.${1:var} = ${2:value};
endsnippet

snippet vartp "this assignment from parameter"
this.${1:var} = $1;
endsnippet

snippet varn "instance variable declaration"
private ${1:type} ${2:var};
endsnippet

snippet new "class initialization"
new ${1:class}(${2:params})
endsnippet

snippet const "constant initialization"
${1:public} static final ${2:type} ${3:name} = ${4:value};
endsnippet

snippet vali "integer value"
Integer.valueOf(${1:num})
endsnippet

snippet valc "character value"
Character.valueOf(${1:num})
endsnippet

# Methods

snippet meth "method declaration"
${1:public} ${2:void} ${3:name}(${4:params}) {
	$0
}
endsnippet

snippet meths "static method declaration"
${1:public} static ${2:void} ${3:name}(${4:params}) {
	$0
}
endsnippet

snippet methd "default method declaration"
default ${1:type} ${2:name}(${3:params}) {
	$0
}
endsnippet

snippet ret "return statement"
return ${1:expression};
endsnippet

snippet get "getter method declaration"
public ${1:type} get${2/\w+/\u$0/g}() {
	return ${2:var};
}
endsnippet

snippet set "setter method declaration"
public void set${2/\w+/\u$0/g}(${1:type} ${2:name}) {
	this.$2 = $2;
}
endsnippet

snippet call "method call"
${1:name}(${2:params});
endsnippet

snippet main "main method declaration"
public static void main(String[] args) {
	$0
}
endsnippet

snippet over "override annotation"
@Override
$0
endsnippet

snippet sings "singleton instance setup"
private static ${1:class} instance = new $1();

public static $1 getInstance() {
	return instance;
}
endsnippet

snippet singi "singleton instance initialization"
${1:class} ${2:var} = $1.getInstance();
endsnippet

# Classes

snippet class "class declaration"
public class ${1:name} {
	$0
}
endsnippet

snippet classa "abstract class declaration"
public abstract class ${1:name} {
	$0
}
endsnippet

snippet classi "inner class"
private static class ${1:name} ${2:${3:extensions} }{
	$0
}
endsnippet

snippet int "interface declaration"
public interface ${1:name} {
	$0
}
endsnippet

snippet enum "enum declaration"
public enum ${1:name} {
	$0
}
endsnippet

snippet ext "extends statement"
extends ${1:class}
endsnippet

snippet impl "implements statement"
implements ${1:class}
endsnippet

snippet pack "package statement"
package ${1:path};
endsnippet

snippet imp "import statement"
import ${1:path};
endsnippet

snippet con "constructor"
public ${1:name}(${2:params}) {
	$0
}
endsnippet

snippet conp "private constructor"
private ${1:name}() {
}
endsnippet

snippet stub "stub class"
class ${1:name}Stub extends $1 {
	$0
}
endsnippet

# Control Flow

snippet if "if statement"
if (${1:cond}) {
	$0
}
endsnippet

snippet ife "if else statement"
if (${1:cond}) {
	${2:if}
} else {
	${3:else}
}
endsnippet

snippet ift "if statement to throw exception"
if (${1:cond}) {
	throw new ${1:exception}("${2:message}");
}
endsnippet

snippet while "while loop"
while (${1:cond}) {
	$0
}
endsnippet

snippet for "for loop"
for (int ${1:index} = 0; $1 < ${2:end}; $1++) {
	$0
}
endsnippet

snippet fore "for each loop"
for (${1:type} ${2:item} : ${3:collection}) {
	$0
}
endsnippet

snippet switch "switch statement"
switch (${1:var}) {
	$0
}
endsnippet

snippet case "case statement"
case ${1:value}:
	$0
	break;
endsnippet

snippet casef "case statement with fall-through"
case ${1:value}:
	$0
endsnippet

snippet de "double equals check" w
${1:var1} == ${2:var2}
endsnippet

snippet ne "negative double equals check" w
${1:var1} != ${2:var2}
endsnippet

snippet eq "equality check" w
${1:var1}.equals(${2:var2})
endsnippet

snippet and "and condition" w
${1:cond1} && ${2:cond2}
endsnippet

snippet or "or condition" w
${1:cond1} || ${2:cond2}
endsnippet

snippet nulln "negative null check" w
${1:expression} != null
endsnippet

snippet nullp "positive null check" w
${1:expression} == null
endsnippet

snippet opt "optional check"
if (${1:var}.isPresent()) {
	return $1.get();
}
throw new ${2:exception}("${3:message}");
endsnippet

snippet lamb "lambda function"
${1:var} -> ${2:exp}
endsnippet

# Exceptions

snippet throw "throw exception"
throw new ${1:exception}("${2:message}");
endsnippet

snippet try "try/catch statement"
try {
	${1:try}
} catch (${2:exception} exception) {
	${3:catch}
}
endsnippet

# Logging

snippet sys "print statement"
System.out.println(${1:exp});
endsnippet

snippet sysm "message print statement"
System.out.println("${1:message}: " + ${2:exp});
endsnippet

snippet sysv "variable print statement"
System.out.println("$1: " + ${1:exp});
endsnippet

snippet log "logger initialization"
private static final Logger LOGGER = LogManager.getLogger();
endsnippet

# Object

snippet hash "hashCode override"
@Override
public int hashCode() {
	return new HashCodeBuilder().append(${1:var})$0.toHashCode();
}
endsnippet

snippet aph "append variable to hashCode" i
.append(${1:var})
endsnippet

snippet equals "equals override"
@Override
public boolean equals(Object obj) {
	if (obj == null) {
		return false;
	}
	if (obj == this) {
		return true;
	}
	if (obj.getClass() != getClass()) {
		return false;
	}
	${1:class} other = ($1) obj;
	return new EqualsBuilder().append(${2:var}, other.$2)$0.isEquals();
}
endsnippet

snippet ape "append variable to equals" i
.append(${1:var}, other.$1)
endsnippet

snippet tos "string representation"
@Override
public String toString() {
	return ${1:var};
}
endsnippet

snippet tosb "string representation with StringBuilder"
@Override
public String toString() {
	StringBuilder builder = new StringBuilder();$0
	return builder.toString();
}
endsnippet

# Collections

snippet list "list initialization"
List<${1:type}> ${2:name} = ${3:new ArrayList<>()};
endsnippet

snippet list2 "nested list initialization"
List<List<${1:type}>> ${2:name} = ${3:new ArrayList<>()};
endsnippet

snippet listg "guava list"
Lists.newArrayList(${1:elements})
endsnippet

snippet set "set initialization"
Set<${1:type}> ${2:name} = ${3:new HashSet<>()};
endsnippet

snippet setg "guava set"
Sets.newHashSet(${1:elements})
endsnippet

snippet map "map initialization"
Map<${1:type1}, ${2:type2}> ${3:name} = ${4:new HashMap<>()};
endsnippet

snippet mapg "guava immutable map"
new ImmutableMap.Builder<${1:type1}, ${2:type2}>().build();
endsnippet

# JUnit

snippet ase "assert equals statement"
assertEquals(${1:expected}, ${2:actual});
endsnippet

snippet ast "assert true statement"
assertTrue(${1:expression});
endsnippet

snippet asf "assert false statement"
assertFalse(${1:expression});
endsnippet

snippet asth "assert exception is thrown"
assertThrows(${1:class}.class, () -> ${2:expression});
endsnippet

snippet classt "test class"
class ${1:name}Test {
	$0
}
endsnippet

snippet inst "instance variable declaration"
private ${1:type} instance;
endsnippet

snippet bef "before each method declaration"
@BeforeEach
void setUp() {
	$0
}
endsnippet

snippet test "test method declaration"
@Test
void ${1:name}() {
	$0
}
endsnippet

# Mockito

snippet mock "mock class"
${1:type} ${2:name} = mock($1.class);
endsnippet

snippet when "when statement"
when(${1:var}.${2:method}(${3:params})).thenReturn(${4:value});
endsnippet

snippet ver "verify statement"
verify(${1:var}).${2:method};
endsnippet

snippet spy "spy statement"
${1:type} ${2:name} = spy($1.class);
endsnippet
